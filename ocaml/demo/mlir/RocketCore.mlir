firrtl.circuit "RocketCore" {
  firrtl.module @RocketCore(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<interrupts flip: bundle<debug: uint<1>, mtip: uint<1>, msip: uint<1>, meip: uint<1>, seip: uint<1>>, hartid flip: uint<64>, imem: bundle<req: bundle<valid: uint<1>, bits: bundle<pc: uint<40>, speculative: uint<1>>>, resp flip: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<btb: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>, pc: uint<40>, data: uint<32>, mask: uint<2>, xcpt_if: uint<1>, replay: uint<1>>>, btb_update: bundle<valid: uint<1>, bits: bundle<prediction: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>, pc: uint<39>, target: uint<39>, taken: uint<1>, isValid: uint<1>, isJump: uint<1>, isReturn: uint<1>, br_pc: uint<39>>>, bht_update: bundle<valid: uint<1>, bits: bundle<prediction: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>, pc: uint<39>, taken: uint<1>, mispredict: uint<1>>>, ras_update: bundle<valid: uint<1>, bits: bundle<isCall: uint<1>, isReturn: uint<1>, returnAddr: uint<39>, prediction: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>>>, flush_icache: uint<1>, flush_tlb: uint<1>, npc flip: uint<40>, acquire flip: uint<1>>, dmem: bundle<req: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<addr: uint<40>, tag: uint<7>, cmd: uint<5>, typ: uint<3>, phys: uint<1>, data: uint<64>>>, s1_kill: uint<1>, s1_data: uint<64>, s2_nack flip: uint<1>, acquire flip: uint<1>, release flip: uint<1>, resp flip: bundle<valid: uint<1>, bits: bundle<addr: uint<40>, tag: uint<7>, cmd: uint<5>, typ: uint<3>, data: uint<64>, replay: uint<1>, has_data: uint<1>, data_word_bypass: uint<64>, store_data: uint<64>>>, replay_next flip: uint<1>, xcpt flip: bundle<ma: bundle<ld: uint<1>, st: uint<1>>, pf: bundle<ld: uint<1>, st: uint<1>>>, invalidate_lr: uint<1>, ordered flip: uint<1>>, ptw flip: bundle<ptbr flip: bundle<mode: uint<4>, asid: uint<16>, ppn: uint<44>>, invalidate flip: uint<1>, status flip: bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>>, fpu flip: bundle<inst flip: uint<32>, fromint_data flip: uint<64>, fcsr_rm flip: uint<3>, fcsr_flags: bundle<valid: uint<1>, bits: uint<5>>, store_data: uint<64>, toint_data: uint<64>, dmem_resp_val flip: uint<1>, dmem_resp_type flip: uint<3>, dmem_resp_tag flip: uint<5>, dmem_resp_data flip: uint<64>, valid flip: uint<1>, fcsr_rdy: uint<1>, nack_mem: uint<1>, illegal_rm: uint<1>, killx flip: uint<1>, killm flip: uint<1>, dec: bundle<cmd: uint<5>, ldst: uint<1>, wen: uint<1>, ren1: uint<1>, ren2: uint<1>, ren3: uint<1>, swap12: uint<1>, swap23: uint<1>, single: uint<1>, fromint: uint<1>, toint: uint<1>, fastpipe: uint<1>, fma: uint<1>, div: uint<1>, sqrt: uint<1>, wflags: uint<1>>, sboard_set: uint<1>, sboard_clr: uint<1>, sboard_clra: uint<5>>, rocc flip: bundle<cmd flip: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<inst: bundle<funct: uint<7>, rs2: uint<5>, rs1: uint<5>, xd: uint<1>, xs1: uint<1>, xs2: uint<1>, rd: uint<5>, opcode: uint<7>>, rs1: uint<64>, rs2: uint<64>, status: bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>>>, resp: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<rd: uint<5>, data: uint<64>>>, mem: bundle<req: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<addr: uint<40>, tag: uint<7>, cmd: uint<5>, typ: uint<3>, phys: uint<1>, data: uint<64>>>, s1_kill: uint<1>, s1_data: uint<64>, s2_nack flip: uint<1>, acquire flip: uint<1>, release flip: uint<1>, resp flip: bundle<valid: uint<1>, bits: bundle<addr: uint<40>, tag: uint<7>, cmd: uint<5>, typ: uint<3>, data: uint<64>, replay: uint<1>, has_data: uint<1>, data_word_bypass: uint<64>, store_data: uint<64>>>, replay_next flip: uint<1>, xcpt flip: bundle<ma: bundle<ld: uint<1>, st: uint<1>>, pf: bundle<ld: uint<1>, st: uint<1>>>, invalidate_lr: uint<1>, ordered flip: uint<1>>, busy: uint<1>, interrupt: uint<1>, exception flip: uint<1>>>) attributes {convention = #firrtl<convention scalarized>} {
    %ex_ctrl = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<legal: uint<1>, fp: uint<1>, rocc: uint<1>, branch: uint<1>, jal: uint<1>, jalr: uint<1>, rxs2: uint<1>, rxs1: uint<1>, sel_alu2: uint<2>, sel_alu1: uint<2>, sel_imm: uint<3>, alu_dw: uint<1>, alu_fn: uint<4>, mem: uint<1>, mem_cmd: uint<5>, mem_type: uint<3>, rfs1: uint<1>, rfs2: uint<1>, rfs3: uint<1>, wfd: uint<1>, div: uint<1>, wxd: uint<1>, csr: uint<3>, fence_i: uint<1>, fence: uint<1>, amo: uint<1>, dp: uint<1>>
    %mem_ctrl = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<legal: uint<1>, fp: uint<1>, rocc: uint<1>, branch: uint<1>, jal: uint<1>, jalr: uint<1>, rxs2: uint<1>, rxs1: uint<1>, sel_alu2: uint<2>, sel_alu1: uint<2>, sel_imm: uint<3>, alu_dw: uint<1>, alu_fn: uint<4>, mem: uint<1>, mem_cmd: uint<5>, mem_type: uint<3>, rfs1: uint<1>, rfs2: uint<1>, rfs3: uint<1>, wfd: uint<1>, div: uint<1>, wxd: uint<1>, csr: uint<3>, fence_i: uint<1>, fence: uint<1>, amo: uint<1>, dp: uint<1>>
    %wb_ctrl = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<legal: uint<1>, fp: uint<1>, rocc: uint<1>, branch: uint<1>, jal: uint<1>, jalr: uint<1>, rxs2: uint<1>, rxs1: uint<1>, sel_alu2: uint<2>, sel_alu1: uint<2>, sel_imm: uint<3>, alu_dw: uint<1>, alu_fn: uint<4>, mem: uint<1>, mem_cmd: uint<5>, mem_type: uint<3>, rfs1: uint<1>, rfs2: uint<1>, rfs3: uint<1>, wfd: uint<1>, div: uint<1>, wxd: uint<1>, csr: uint<3>, fence_i: uint<1>, fence: uint<1>, amo: uint<1>, dp: uint<1>>
    %ex_reg_xcpt_interrupt = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_valid = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_rvc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_btb_hit = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_btb_resp = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>
    %ex_reg_xcpt = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_flush_pipe = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_load_use = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_cause = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %ex_reg_replay = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ex_reg_pc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %ex_reg_inst = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<32>
    %mem_reg_xcpt_interrupt = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_valid = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_rvc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_btb_hit = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_btb_resp = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>
    %mem_reg_xcpt = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_replay = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_flush_pipe = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_cause = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %mem_reg_slow_bypass = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_load = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_store = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %mem_reg_pc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %mem_reg_inst = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<32>
    %mem_reg_wdata = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %mem_reg_rs2 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %take_pc_mem = firrtl.wire : !firrtl.uint<1>
    %wb_reg_valid = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %wb_reg_xcpt = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %wb_reg_replay = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %wb_reg_cause = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %wb_reg_pc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %wb_reg_inst = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<32>
    %wb_reg_wdata = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %wb_reg_rs2 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %take_pc_wb = firrtl.wire : !firrtl.uint<1>
    %take_pc_id = firrtl.wire : !firrtl.uint<1>
    %take_pc_mem_wb = firrtl.node %158 : !firrtl.uint<1>
    %take_pc = firrtl.node %159 : !firrtl.uint<1>
    %ibuf_clock, %ibuf_reset, %ibuf_io = firrtl.instance ibuf @IBuf(in clock: !firrtl.clock, in reset: !firrtl.uint<1>, out io: !firrtl.bundle<imem flip: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<btb: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>, pc: uint<40>, data: uint<32>, mask: uint<2>, xcpt_if: uint<1>, replay: uint<1>>>, kill flip: uint<1>, pc: uint<40>, btb_resp: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>, inst: vector<bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<pf0: uint<1>, pf1: uint<1>, replay: uint<1>, btb_hit: uint<1>, rvc: uint<1>, inst: bundle<bits: uint<32>, rd: uint<5>, rs1: uint<5>, rs2: uint<5>, rs3: uint<5>>, raw: uint<32>>>, 1>>)
    %id_ctrl = firrtl.wire : !firrtl.bundle<legal: uint<1>, fp: uint<1>, rocc: uint<1>, branch: uint<1>, jal: uint<1>, jalr: uint<1>, rxs2: uint<1>, rxs1: uint<1>, sel_alu2: uint<2>, sel_alu1: uint<2>, sel_imm: uint<3>, alu_dw: uint<1>, alu_fn: uint<4>, mem: uint<1>, mem_cmd: uint<5>, mem_type: uint<3>, rfs1: uint<1>, rfs2: uint<1>, rfs3: uint<1>, wfd: uint<1>, div: uint<1>, wxd: uint<1>, csr: uint<3>, fence_i: uint<1>, fence: uint<1>, amo: uint<1>, dp: uint<1>>
    %id_load_use = firrtl.wire : !firrtl.uint<1>
    %id_reg_fence = firrtl.regreset %clock, %reset, %c0_ui1_79 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    %id_rs_0 = firrtl.wire : !firrtl.uint<64>
    %id_rs_1 = firrtl.wire : !firrtl.uint<64>
    %ctrl_killd = firrtl.wire : !firrtl.uint<1>
    %id_npc = firrtl.node %1198 : !firrtl.uint<40>
    %csr_clock, %csr_reset, %csr_io = firrtl.instance csr @CSRFile(in clock: !firrtl.clock, in reset: !firrtl.uint<1>, out io: !firrtl.bundle<interrupts flip: bundle<debug: uint<1>, mtip: uint<1>, msip: uint<1>, meip: uint<1>, seip: uint<1>>, hartid flip: uint<64>, rw: bundle<addr flip: uint<12>, cmd flip: uint<3>, rdata: uint<64>, wdata flip: uint<64>>, decode: bundle<csr flip: uint<12>, fp_illegal: uint<1>, rocc_illegal: uint<1>, read_illegal: uint<1>, write_illegal: uint<1>, write_flush: uint<1>, system_illegal: uint<1>>, csr_stall: uint<1>, eret: uint<1>, singleStep: uint<1>, status: bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>, ptbr: bundle<mode: uint<4>, asid: uint<16>, ppn: uint<44>>, evec: uint<40>, exception flip: uint<1>, retire flip: uint<1>, custom_mrw_csrs: vector<uint<64>, 0>, cause flip: uint<64>, pc flip: uint<40>, badaddr flip: uint<40>, fatc: uint<1>, time: uint<64>, fcsr_rm: uint<3>, fcsr_flags flip: bundle<valid: uint<1>, bits: uint<5>>, rocc_interrupt flip: uint<1>, interrupt: uint<1>, interrupt_cause: uint<64>, bp: vector<bundle<control: bundle<ttype: uint<4>, dmode: uint<1>, maskmax: uint<6>, reserved: uint<40>, action: uint<1>, chain: uint<1>, zero: uint<2>, tmatch: uint<2>, m: uint<1>, h: uint<1>, s: uint<1>, u: uint<1>, x: uint<1>, w: uint<1>, r: uint<1>>, address: uint<39>>, 1>, counters: vector<bundle<eventSel: uint<64>, inc flip: uint<1>>, 0>>)
    %id_csr_en = firrtl.node %1250 : !firrtl.uint<1>
    %id_system_insn = firrtl.node %1251 : !firrtl.uint<1>
    %id_csr_ren = firrtl.node %1257 : !firrtl.uint<1>
    %id_csr = firrtl.node %1258 : !firrtl.uint<3>
    %id_csr_flush = firrtl.node %1265 : !firrtl.uint<1>
    %id_illegal_insn = firrtl.node %1321 : !firrtl.uint<1>
    %id_amo_aq = firrtl.node %1322 : !firrtl.uint<1>
    %id_amo_rl = firrtl.node %1323 : !firrtl.uint<1>
    %id_fence_next = firrtl.node %1326 : !firrtl.uint<1>
    %id_mem_busy = firrtl.node %1329 : !firrtl.uint<1>
    %id_rocc_busy = firrtl.node %1342 : !firrtl.uint<1>
    %id_do_fence = firrtl.node %1361 : !firrtl.uint<1>
    %bpu_clock, %bpu_reset, %bpu_io = firrtl.instance bpu @BreakpointUnit(in clock: !firrtl.clock, in reset: !firrtl.uint<1>, out io: !firrtl.bundle<status flip: bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>, bp flip: vector<bundle<control: bundle<ttype: uint<4>, dmode: uint<1>, maskmax: uint<6>, reserved: uint<40>, action: uint<1>, chain: uint<1>, zero: uint<2>, tmatch: uint<2>, m: uint<1>, h: uint<1>, s: uint<1>, u: uint<1>, x: uint<1>, w: uint<1>, r: uint<1>>, address: uint<39>>, 1>, pc flip: uint<39>, ea flip: uint<39>, xcpt_if: uint<1>, xcpt_ld: uint<1>, xcpt_st: uint<1>, debug_if: uint<1>, debug_ld: uint<1>, debug_st: uint<1>>)
    %id_xcpt_if = firrtl.node %1375 : !firrtl.uint<1>
    %id_xcpt = firrtl.node %1382 : !firrtl.uint<1>
    %id_cause = firrtl.node %1389 : !firrtl.uint<64>
    %ex_waddr = firrtl.node %1390 : !firrtl.uint<5>
    %mem_waddr = firrtl.node %1391 : !firrtl.uint<5>
    %wb_waddr = firrtl.node %1392 : !firrtl.uint<5>
    %id_bypass_src_0_0 = firrtl.node %1403 : !firrtl.uint<1>
    %id_bypass_src_0_1 = firrtl.node %1406 : !firrtl.uint<1>
    %id_bypass_src_0_2 = firrtl.node %1409 : !firrtl.uint<1>
    %id_bypass_src_0_3 = firrtl.node %1411 : !firrtl.uint<1>
    %id_bypass_src_1_0 = firrtl.node %1413 : !firrtl.uint<1>
    %id_bypass_src_1_1 = firrtl.node %1416 : !firrtl.uint<1>
    %id_bypass_src_1_2 = firrtl.node %1419 : !firrtl.uint<1>
    %id_bypass_src_1_3 = firrtl.node %1421 : !firrtl.uint<1>
    %bypass_mux = firrtl.wire : !firrtl.vector<uint<64>, 4>
    %ex_reg_rs_bypass = firrtl.reg %clock : !firrtl.clock, !firrtl.vector<uint<1>, 2>
    %ex_reg_rs_lsb = firrtl.reg %clock : !firrtl.clock, !firrtl.vector<uint<2>, 2>
    %ex_reg_rs_msb = firrtl.reg %clock : !firrtl.clock, !firrtl.vector<uint<62>, 2>
    %ex_rs_0 = firrtl.node %1439 : !firrtl.uint<64>
    %ex_rs_1 = firrtl.node %1443 : !firrtl.uint<64>
    %ex_imm = firrtl.node %1555 : !firrtl.sint<32>
    %ex_op1 = firrtl.node %1566 : !firrtl.sint<64>
    %ex_op2 = firrtl.node %1583 : !firrtl.sint<64>
    %alu_clock, %alu_reset, %alu_io = firrtl.instance alu @ALU(in clock: !firrtl.clock, in reset: !firrtl.uint<1>, out io: !firrtl.bundle<dw flip: uint<1>, fn flip: uint<4>, in2 flip: uint<64>, in1 flip: uint<64>, out: uint<64>, adder_out: uint<64>, cmp_out: uint<1>>)
    %div_clock, %div_reset, %div_io = firrtl.instance div @MulDiv(in clock: !firrtl.clock, in reset: !firrtl.uint<1>, out io: !firrtl.bundle<req flip: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<fn: uint<4>, dw: uint<1>, in1: uint<64>, in2: uint<64>, tag: uint<5>>>, kill flip: uint<1>, resp: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<data: uint<64>, tag: uint<5>>>>)
    %ex_pc_valid = firrtl.node %1639 : !firrtl.uint<1>
    %wb_dcache_miss = firrtl.node %1642 : !firrtl.uint<1>
    %replay_ex_structural = firrtl.node %1651 : !firrtl.uint<1>
    %replay_ex_load_use = firrtl.node %1652 : !firrtl.uint<1>
    %replay_ex = firrtl.node %1657 : !firrtl.uint<1>
    %ctrl_killx = firrtl.node %1662 : !firrtl.uint<1>
    %ex_slow_bypass = firrtl.node %1688 : !firrtl.uint<1>
    %ex_xcpt = firrtl.node %1689 : !firrtl.uint<1>
    %mem_pc_valid = firrtl.node %1692 : !firrtl.uint<1>
    %mem_br_taken = firrtl.node %1693 : !firrtl.uint<1>
    %mem_br_target = firrtl.node %1917 : !firrtl.sint<40>
    %mem_npc = firrtl.node %1963 : !firrtl.uint<40>
    %mem_misprediction = firrtl.node %1970 : !firrtl.uint<1>
    %mem_npc_misaligned = firrtl.node %1976 : !firrtl.uint<1>
    %mem_int_wdata = firrtl.node %1987 : !firrtl.uint<64>
    %mem_cfi = firrtl.node %1990 : !firrtl.uint<1>
    %mem_cfi_taken = firrtl.node %1995 : !firrtl.uint<1>
    %mem_direction_misprediction = firrtl.node %2000 : !firrtl.uint<1>
    %mem_breakpoint = firrtl.node %2021 : !firrtl.uint<1>
    %mem_debug_breakpoint = firrtl.node %2026 : !firrtl.uint<1>
    %mem_new_xcpt = firrtl.node %2045 : !firrtl.uint<1>
    %mem_new_cause = firrtl.node %2056 : !firrtl.uint<4>
    %mem_xcpt = firrtl.node %2061 : !firrtl.uint<1>
    %mem_cause = firrtl.node %2062 : !firrtl.uint<64>
    %dcache_kill_mem = firrtl.node %2064 : !firrtl.uint<1>
    %fpu_kill_mem = firrtl.node %2067 : !firrtl.uint<1>
    %replay_mem = firrtl.node %2070 : !firrtl.uint<1>
    %killm_common = firrtl.node %2077 : !firrtl.uint<1>
    %2080 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ctrl_killm = firrtl.node %2085 : !firrtl.uint<1>
    %wb_wxd = firrtl.node %2095 : !firrtl.uint<1>
    %wb_set_sboard = firrtl.node %2098 : !firrtl.uint<1>
    %replay_wb_common = firrtl.node %2099 : !firrtl.uint<1>
    %replay_wb_rocc = firrtl.node %2103 : !firrtl.uint<1>
    %replay_wb = firrtl.node %2104 : !firrtl.uint<1>
    %dmem_resp_xpu = firrtl.node %2113 : !firrtl.uint<1>
    %dmem_resp_fpu = firrtl.node %2115 : !firrtl.uint<1>
    %dmem_resp_waddr = firrtl.node %2116 : !firrtl.uint<5>
    %dmem_resp_valid = firrtl.node %2117 : !firrtl.uint<1>
    %dmem_resp_replay = firrtl.node %2118 : !firrtl.uint<1>
    %ll_wdata = firrtl.wire : !firrtl.uint<64>
    %ll_waddr = firrtl.wire : !firrtl.uint<5>
    %ll_wen = firrtl.wire : !firrtl.uint<1>
    %wb_valid = firrtl.node %2133 : !firrtl.uint<1>
    %wb_wen = firrtl.node %2134 : !firrtl.uint<1>
    %rf_wen = firrtl.node %2135 : !firrtl.uint<1>
    %rf_waddr = firrtl.node %2136 : !firrtl.uint<5>
    %rf_wdata = firrtl.node %2145 : !firrtl.uint<64>
    %2202 = firrtl.regreset %clock, %reset, %c0_ui32 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<32>, !firrtl.uint<32>
    %id_sboard_hazard = firrtl.node %2237 : !firrtl.uint<1>
    %ex_cannot_bypass = firrtl.node %2258 : !firrtl.uint<1>
    %data_hazard_ex = firrtl.node %2273 : !firrtl.uint<1>
    %fp_data_hazard_ex = firrtl.node %2293 : !firrtl.uint<1>
    %id_ex_hazard = firrtl.node %2298 : !firrtl.uint<1>
    %mem_mem_cmd_bh = firrtl.node %2299 : !firrtl.uint<1>
    %mem_cannot_bypass = firrtl.node %2310 : !firrtl.uint<1>
    %data_hazard_mem = firrtl.node %2325 : !firrtl.uint<1>
    %fp_data_hazard_mem = firrtl.node %2345 : !firrtl.uint<1>
    %id_mem_hazard = firrtl.node %2350 : !firrtl.uint<1>
    %data_hazard_wb = firrtl.node %2371 : !firrtl.uint<1>
    %fp_data_hazard_wb = firrtl.node %2391 : !firrtl.uint<1>
    %id_wb_hazard = firrtl.node %2396 : !firrtl.uint<1>
    %2397 = firrtl.regreset %clock, %reset, %c0_ui32 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<32>, !firrtl.uint<32>
    %id_stall_fpu = firrtl.node %2467 : !firrtl.uint<1>
    %dcache_blocked = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %rocc_blocked = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ctrl_stalld = firrtl.node %2514 : !firrtl.uint<1>
    %ex_dcache_tag = firrtl.node %2620 : !firrtl.uint<6>
    %2711 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %2713 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %2717 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %2719 = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
  firrtl.module private @IBuf(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<imem flip: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<btb: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>, pc: uint<40>, data: uint<32>, mask: uint<2>, xcpt_if: uint<1>, replay: uint<1>>>, kill flip: uint<1>, pc: uint<40>, btb_resp: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>, inst: vector<bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<pf0: uint<1>, pf1: uint<1>, replay: uint<1>, btb_hit: uint<1>, rvc: uint<1>, inst: bundle<bits: uint<32>, rd: uint<5>, rs1: uint<5>, rs2: uint<5>, rs3: uint<5>>, raw: uint<32>>>, 1>>) {
    %nBufValid = firrtl.regreset %clock, %reset, %c0_ui1 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    %buf = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<btb: bundle<valid: uint<1>, bits: bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>>, pc: uint<40>, data: uint<32>, mask: uint<2>, xcpt_if: uint<1>, replay: uint<1>>
    %ibufBTBHit = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %ibufBTBResp = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<taken: uint<1>, mask: uint<2>, bridx: uint<1>, target: uint<39>, entry: uint<6>, bht: bundle<history: uint<7>, value: uint<2>>>
    %pcWordBits = firrtl.node %33 : !firrtl.uint<1>
    %nReady = firrtl.wire : !firrtl.uint<2>
    %nIC = firrtl.node %44 : !firrtl.uint<2>
    %nICReady = firrtl.node %49 : !firrtl.uint<2>
    %nValid = firrtl.node %54 : !firrtl.uint<2>
    %icShiftAmt = firrtl.node %107 : !firrtl.uint<2>
    %icData = firrtl.node %126 : !firrtl.uint<32>
    %icMask = firrtl.node %133 : !firrtl.uint<32>
    %inst = firrtl.node %140 : !firrtl.uint<32>
    %valid = firrtl.node %149 : !firrtl.uint<2>
    %bufMask = firrtl.node %156 : !firrtl.uint<2>
    %xcpt_if = firrtl.node %165 : !firrtl.uint<2>
    %ic_replay = firrtl.node %173 : !firrtl.uint<2>
    %ibufBTBHitMask = firrtl.node %176 : !firrtl.uint<2>
    %icBTBHitMask = firrtl.node %197 : !firrtl.uint<4>
    %btbHitMask = firrtl.node %203 : !firrtl.uint<4>
    %RVCExpander_clock, %RVCExpander_reset, %RVCExpander_io = firrtl.instance RVCExpander @RVCExpander(in clock: !firrtl.clock, in reset: !firrtl.uint<1>, out io: !firrtl.bundle<in flip: uint<32>, out: bundle<bits: uint<32>, rd: uint<5>, rs1: uint<5>, rs2: uint<5>, rs3: uint<5>>, rvc: uint<1>>)
  firrtl.module private @CSRFile(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<interrupts flip: bundle<debug: uint<1>, mtip: uint<1>, msip: uint<1>, meip: uint<1>, seip: uint<1>>, hartid flip: uint<64>, rw: bundle<addr flip: uint<12>, cmd flip: uint<3>, rdata: uint<64>, wdata flip: uint<64>>, decode: bundle<csr flip: uint<12>, fp_illegal: uint<1>, rocc_illegal: uint<1>, read_illegal: uint<1>, write_illegal: uint<1>, write_flush: uint<1>, system_illegal: uint<1>>, csr_stall: uint<1>, eret: uint<1>, singleStep: uint<1>, status: bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>, ptbr: bundle<mode: uint<4>, asid: uint<16>, ppn: uint<44>>, evec: uint<40>, exception flip: uint<1>, retire flip: uint<1>, custom_mrw_csrs: vector<uint<64>, 0>, cause flip: uint<64>, pc flip: uint<40>, badaddr flip: uint<40>, fatc: uint<1>, time: uint<64>, fcsr_rm: uint<3>, fcsr_flags flip: bundle<valid: uint<1>, bits: uint<5>>, rocc_interrupt flip: uint<1>, interrupt: uint<1>, interrupt_cause: uint<64>, bp: vector<bundle<control: bundle<ttype: uint<4>, dmode: uint<1>, maskmax: uint<6>, reserved: uint<40>, action: uint<1>, chain: uint<1>, zero: uint<2>, tmatch: uint<2>, m: uint<1>, h: uint<1>, s: uint<1>, u: uint<1>, x: uint<1>, w: uint<1>, r: uint<1>>, address: uint<39>>, 1>, counters: vector<bundle<eventSel: uint<64>, inc flip: uint<1>>, 0>>) {
    %reset_mstatus = firrtl.wire : !firrtl.bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>
    %reg_mstatus = firrtl.regreset %clock, %reset, %reset_mstatus : !firrtl.clock, !firrtl.uint<1>, !firrtl.bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>, !firrtl.bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>
    %new_prv = firrtl.wire : !firrtl.uint<2>
    %reset_dcsr = firrtl.wire : !firrtl.bundle<xdebugver: uint<2>, ndreset: uint<1>, fullreset: uint<1>, zero3: uint<12>, ebreakm: uint<1>, ebreakh: uint<1>, ebreaks: uint<1>, ebreaku: uint<1>, zero2: uint<1>, stopcycle: uint<1>, stoptime: uint<1>, cause: uint<3>, debugint: uint<1>, zero1: uint<1>, halt: uint<1>, step: uint<1>, prv: uint<2>>
    %reg_dcsr = firrtl.regreset %clock, %reset, %reset_dcsr : !firrtl.clock, !firrtl.uint<1>, !firrtl.bundle<xdebugver: uint<2>, ndreset: uint<1>, fullreset: uint<1>, zero3: uint<12>, ebreakm: uint<1>, ebreakh: uint<1>, ebreaks: uint<1>, ebreaku: uint<1>, zero2: uint<1>, stopcycle: uint<1>, stoptime: uint<1>, cause: uint<3>, debugint: uint<1>, zero1: uint<1>, halt: uint<1>, step: uint<1>, prv: uint<2>>, !firrtl.bundle<xdebugver: uint<2>, ndreset: uint<1>, fullreset: uint<1>, zero3: uint<12>, ebreakm: uint<1>, ebreakh: uint<1>, ebreaks: uint<1>, ebreaku: uint<1>, zero2: uint<1>, stopcycle: uint<1>, stoptime: uint<1>, cause: uint<3>, debugint: uint<1>, zero1: uint<1>, halt: uint<1>, step: uint<1>, prv: uint<2>>
    %supported_interrupts = firrtl.node %346 : !firrtl.uint<13>
    %delegable_interrupts = firrtl.node %369 : !firrtl.uint<13>
    %reg_debug = firrtl.regreset %clock, %reset, %c0_ui1 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    %effective_prv = firrtl.node %370 : !firrtl.uint<3>
    %reg_dpc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %reg_dscratch = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_singleStepped = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %reg_tselect = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %reg_bp = firrtl.reg %clock : !firrtl.clock, !firrtl.vector<bundle<control: bundle<ttype: uint<4>, dmode: uint<1>, maskmax: uint<6>, reserved: uint<40>, action: uint<1>, chain: uint<1>, zero: uint<2>, tmatch: uint<2>, m: uint<1>, h: uint<1>, s: uint<1>, u: uint<1>, x: uint<1>, w: uint<1>, r: uint<1>>, address: uint<39>>, 2>
    %reg_mie = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_mideleg = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_medeleg = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_mip = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<rocc: uint<1>, meip: uint<1>, heip: uint<1>, seip: uint<1>, ueip: uint<1>, mtip: uint<1>, htip: uint<1>, stip: uint<1>, utip: uint<1>, msip: uint<1>, hsip: uint<1>, ssip: uint<1>, usip: uint<1>>
    %reg_mepc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %reg_mcause = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_mbadaddr = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %reg_mscratch = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_mtvec = firrtl.regreset %clock, %reset, %c0_ui32 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<32>, !firrtl.uint<32>
    %reg_mcounteren = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<32>
    %reg_scounteren = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<32>
    %reg_sepc = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %reg_scause = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_sbadaddr = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<40>
    %reg_sscratch = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<64>
    %reg_stvec = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<39>
    %reg_sptbr = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<mode: uint<4>, asid: uint<16>, ppn: uint<44>>
    %reg_wfi = firrtl.regreset %clock, %reset, %c0_ui1 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    %reg_fflags = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<5>
    %reg_frm = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<3>
    %405 = firrtl.regreset %clock, %reset, %c0_ui6 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<6>, !firrtl.uint<6>
    %409 = firrtl.regreset %clock, %reset, %c0_ui58 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<58>, !firrtl.uint<58>
    %414 = firrtl.regreset %clock, %reset, %c0_ui6 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<6>, !firrtl.uint<6>
    %418 = firrtl.regreset %clock, %reset, %c0_ui58 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<58>, !firrtl.uint<58>
    %hpm_mask = firrtl.node %429 : !firrtl.uint<32>
    %mip = firrtl.wire : !firrtl.bundle<rocc: uint<1>, meip: uint<1>, heip: uint<1>, seip: uint<1>, ueip: uint<1>, mtip: uint<1>, htip: uint<1>, stip: uint<1>, utip: uint<1>, msip: uint<1>, hsip: uint<1>, ssip: uint<1>, usip: uint<1>>
    %read_mip = firrtl.node %467 : !firrtl.uint<13>
    %pending_interrupts = firrtl.node %468 : !firrtl.uint<64>
    %m_interrupts = firrtl.node %481 : !firrtl.uint<64>
    %s_interrupts = firrtl.node %495 : !firrtl.uint<64>
    %all_interrupts = firrtl.node %496 : !firrtl.uint<64>
    %interruptCause = firrtl.node %753 : !firrtl.uint<64>
    %reg_misa = firrtl.regreset %clock, %reset, %c9223372036856090925_ui64 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<64>, !firrtl.uint<64>
    %read_mstatus = firrtl.node %825 : !firrtl.uint<64>
    %wdata = firrtl.node %1315 : !firrtl.uint<64>
    %system_insn = firrtl.node %1316 : !firrtl.uint<1>
    %opcode = firrtl.node %1319 : !firrtl.uint<8>
    %insn_rs2 = firrtl.node %1320 : !firrtl.uint<1>
    %insn_call = firrtl.node %1327 : !firrtl.uint<1>
    %insn_break = firrtl.node %1330 : !firrtl.uint<1>
    %insn_ret = firrtl.node %1333 : !firrtl.uint<1>
    %insn_wfi = firrtl.node %1336 : !firrtl.uint<1>
    %insn_sfence_vma = firrtl.node %1337 : !firrtl.uint<1>
    %allow_wfi = firrtl.node %1344 : !firrtl.uint<1>
    %allow_sfence_vma = firrtl.node %1350 : !firrtl.uint<1>
    %allow_sret = firrtl.node %1356 : !firrtl.uint<1>
    %cause = firrtl.node %2009 : !firrtl.uint<64>
    %cause_lsbs = firrtl.node %2010 : !firrtl.uint<6>
    %causeIsDebugInt = firrtl.node %2015 : !firrtl.uint<1>
    %causeIsDebugTrigger = firrtl.node %2020 : !firrtl.uint<1>
    %causeIsDebugBreak = firrtl.node %2036 : !firrtl.uint<1>
    %trapToDebug = firrtl.node %2045 : !firrtl.uint<1>
    %delegate = firrtl.node %2060 : !firrtl.uint<1>
    %debugTVec = firrtl.node %2061 : !firrtl.uint<12>
    %tvec = firrtl.node %2067 : !firrtl.uint<40>
    %exception = firrtl.node %2088 : !firrtl.uint<1>
  firrtl.module private @BreakpointUnit(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<status flip: bundle<debug: uint<1>, isa: uint<32>, prv: uint<2>, sd: uint<1>, zero2: uint<27>, sxl: uint<2>, uxl: uint<2>, sd_rv32: uint<1>, zero1: uint<8>, tsr: uint<1>, tw: uint<1>, tvm: uint<1>, mxr: uint<1>, pum: uint<1>, mprv: uint<1>, xs: uint<2>, fs: uint<2>, mpp: uint<2>, hpp: uint<2>, spp: uint<1>, mpie: uint<1>, hpie: uint<1>, spie: uint<1>, upie: uint<1>, mie: uint<1>, hie: uint<1>, sie: uint<1>, uie: uint<1>>, bp flip: vector<bundle<control: bundle<ttype: uint<4>, dmode: uint<1>, maskmax: uint<6>, reserved: uint<40>, action: uint<1>, chain: uint<1>, zero: uint<2>, tmatch: uint<2>, m: uint<1>, h: uint<1>, s: uint<1>, u: uint<1>, x: uint<1>, w: uint<1>, r: uint<1>>, address: uint<39>>, 1>, pc flip: uint<39>, ea flip: uint<39>, xcpt_if: uint<1>, xcpt_ld: uint<1>, xcpt_st: uint<1>, debug_if: uint<1>, debug_ld: uint<1>, debug_st: uint<1>>) {
  firrtl.module private @ALU(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<dw flip: uint<1>, fn flip: uint<4>, in2 flip: uint<64>, in1 flip: uint<64>, out: uint<64>, adder_out: uint<64>, cmp_out: uint<1>>) {
    %in2_inv = firrtl.node %11 : !firrtl.uint<64>
    %in1_xor_in2 = firrtl.node %12 : !firrtl.uint<64>
    %shamt = firrtl.node %71 : !firrtl.uint<6>
    %shin_r = firrtl.node %74 : !firrtl.uint<64>
    %shin = firrtl.node %199 : !firrtl.uint<64>
    %shout_r = firrtl.node %211 : !firrtl.uint<64>
    %shout_l = firrtl.node %327 : !firrtl.uint<64>
    %shout = firrtl.node %338 : !firrtl.uint<64>
    %logic = firrtl.node %356 : !firrtl.uint<64>
    %shift_logic = firrtl.node %371 : !firrtl.uint<64>
    %out = firrtl.node %378 : !firrtl.uint<64>
  firrtl.module private @MulDiv(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<req flip: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<fn: uint<4>, dw: uint<1>, in1: uint<64>, in2: uint<64>, tag: uint<5>>>, kill flip: uint<1>, resp: bundle<ready flip: uint<1>, valid: uint<1>, bits: bundle<data: uint<64>, tag: uint<5>>>>) {
    %state = firrtl.regreset %clock, %reset, %c0_ui3 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<3>, !firrtl.uint<3>
    %req = firrtl.reg %clock : !firrtl.clock, !firrtl.bundle<fn: uint<4>, dw: uint<1>, in1: uint<64>, in2: uint<64>, tag: uint<5>>
    %count = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<7>
    %neg_out = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %isMul = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %isHi = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<1>
    %divisor = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<65>
    %remainder = firrtl.reg %clock : !firrtl.clock, !firrtl.uint<130>
    %cmdMul = firrtl.node %60 : !firrtl.uint<1>
    %cmdHi = firrtl.node %61 : !firrtl.uint<1>
    %lhsSigned = firrtl.node %62 : !firrtl.uint<1>
    %rhsSigned = firrtl.node %63 : !firrtl.uint<1>
    %lhs_sign = firrtl.node %74 : !firrtl.uint<1>
    %lhs_in = firrtl.node %85 : !firrtl.uint<64>
    %rhs_sign = firrtl.node %95 : !firrtl.uint<1>
    %rhs_in = firrtl.node %106 : !firrtl.uint<64>
    %subtractor = firrtl.node %113 : !firrtl.uint<65>
    %negated_remainder = firrtl.node %120 : !firrtl.uint<64>
  firrtl.module private @RVCExpander(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %io: !firrtl.bundle<in flip: uint<32>, out: bundle<bits: uint<32>, rd: uint<5>, rs1: uint<5>, rs2: uint<5>, rs3: uint<5>>, rvc: uint<1>>) {
